package models

import (
	"bytes"
	"crypto/ecdsa"
	"github.com/shopspring/decimal"
	"time"

	"github.com/ethereum/go-ethereum/common/hexutil"

	"github.com/MetaBloxIO/metablox-foundation-services/errval"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

const Secp256k1Sig = "EcdsaSecp256k1Signature2019"
const Secp256k1Key = "EcdsaSecp256k1RecoveryMethod2020"
const PurposeAuth = "Authentication"

const ContextDID = "https://w3id.org/did/v1"
const ContextCredential = "https://www.w3.org/2018/credentials/v1"
const ContextSecp256k1 = "https://identity.foundation/EcdsaSecp256k1RecoverySignature2020#"

const TypeCredential = "VerifiableCredential"
const TypeWifi = "WifiAccess"
const TypeMining = "MiningLicense"

type DIDDocument struct {
	Context            []string             `json:"@context" mapstructure:"@context"`
	ID                 string               `json:"id"`
	Created            string               `json:"created"`
	Updated            string               `json:"updated"`
	Version            int                  `json:"version"`
	VerificationMethod []VerificationMethod `json:"verificationMethod"`
	Authentication     string               `json:"authentication"`
	Service            []Service            `json:"service"`
}

type RegisterDID struct {
	Did     string `json:"did"`
	Account string `json:"account"`
	SigV    uint8  `json:"sigV"`
	SigR    string `json:"sigR"`
	SigS    string `json:"sigS"`
}

func (c *RegisterDID) Address() common.Address {
	return common.HexToAddress(c.Account)
}

func (c *RegisterDID) SigRBytes32() [32]byte {
	var t [32]byte
	r, _ := hexutil.Decode(c.SigR)
	copy(t[:], r[:32])
	return t
}

func (c *RegisterDID) SigSBytes32() [32]byte {
	var t [32]byte
	s, _ := hexutil.Decode(c.SigS)
	copy(t[:], s[:32])
	return t
}

func (c *RegisterDID) ToSigBytes() []byte {
	var signBytes []byte
	r, _ := hexutil.Decode(c.SigR)
	s, _ := hexutil.Decode(c.SigS)
	signBytes = bytes.Join([][]byte{r, s}, nil)
	signBytes = append(signBytes, byte(c.SigV-27))
	return signBytes
}

type VerificationMethod struct {
	ID                  string `json:"id"`
	MethodType          string `json:"type"`
	Controller          string `json:"controller"`
	BlockchainAccountId string `json:"blockchainAccountId"`
}

type ResolutionOptions struct {
	Accept string `json:"accept"`
}

type RepresentationResolutionOptions struct {
	Accept string `json:"accept"`
}

type ResolutionMetadata struct {
	Error string `json:"error"`
}

type RepresentationResolutionMetadata struct {
	ContentType string `json:"contentType"`
	Error       string `json:"error"`
}

type DocumentMetadata struct {
	Created       string   `json:"created"`
	Updated       string   `json:"updated"`
	Deactivated   string   `json:"deactivated"`
	NextUpdate    string   `json:"nextUpdate"`
	VersionID     string   `json:"versionId"`
	NextVersionID string   `json:"nextVersionId"`
	EquivalentID  []string `json:"equivalentId"`
	CanonicalID   string   `json:"canonicalId"`
}

type VerifiableCredential struct {
	Context           []string    `json:"@context" mapstructure:"@context"`
	ID                string      `json:"id" db:"ID"`
	Type              []string    `json:"type"`
	Issuer            string      `json:"issuer" db:"Issuer"`
	IssuanceDate      string      `json:"issuanceDate" db:"IssuanceDate"`
	ExpirationDate    string      `json:"expirationDate" db:"ExpirationDate"`
	Description       string      `json:"description" db:"Description"`
	CredentialSubject interface{} `json:"credentialSubject"`
	Proof             VCProof     `json:"proof"`
	Revoked           bool        `json:"revoked" db:"Revoked"`
}

// This can be a type of input form to set up the VC.
// Temp fields here currently, will be changed in the future
type SubjectInfo struct {
	ID           string `json:"id"`
	GivenName    string `json:"givenName"`
	FamilyName   string `json:"familyName"`
	Gender       string `json:"gender"`
	BirthCountry string `json:"birthCountry"`
	BirthDate    string `json:"birthName"`
}

type VCProof struct {
	Type               string `json:"type"`
	Created            string `json:"created"`
	VerificationMethod string `json:"verificationMethod"`
	ProofPurpose       string `json:"proofPurpose"`
	JWSSignature       string `json:"jws"`             //signature is created from a hash of the VC
	PublicKeyString    []byte `json:"publicKeyString"` //public key (belonging to issuer) used for verification
}

type VPProof struct {
	Type               string `json:"type"`
	Created            string `json:"created"`
	VerificationMethod string `json:"verificationMethod"`
	ProofPurpose       string `json:"proofPurpose"`
	JWSSignature       string `json:"jws"`             //signature is created from a hash of the VP
	Nonce              string `json:"nonce"`           //random value generated by verifier that must be included in proof
	PublicKeyString    []byte `json:"publicKeyString"` //public key (belonging to holder) used for verification
}

type VerifiablePresentation struct {
	Context              []string               `json:"@context" mapstructure:"@context"`
	Type                 []string               `json:"type"`
	VerifiableCredential []VerifiableCredential `json:"verifiableCredential"`
	Holder               string                 `json:"holder"`
	Proof                VPProof                `json:"proof"`
}

type Service struct {
	ID              string `json:"id"`
	Type            string `json:"type"`
	ServiceEndpoint string `json:"serviceEndpoint"`
}

type WifiAccessInfo struct {
	CredentialID string `json:"-" db:"CredentialID"`
	ID           string `json:"id" db:"ID"`     //id of the user the credential is assigned to
	Type         string `json:"type" db:"Type"` //user or validator
}

type MiningLicenseInfo struct {
	CredentialID string `json:"-" db:"CredentialID"`
	ID           string `json:"id" db:"ID"`     //id of the user the credential is assigned to
	Name         string `json:"name" db:"Name"` //manufacturer name
	Model        string `json:"model" db:"Model"`
	Serial       string `json:"serial" db:"Serial"` //serial number
}

type MinerInfo struct {
	ID             string          `db:"ID" json:"id"`
	Name           string          `db:"Name" json:"name"`
	SSID           *string         `db:"SSID" json:"ssid"`
	BSSID          *string         `db:"BSSID" json:"bssid"`
	Longitude      decimal.Decimal `db:"Longitude" json:"longitude"`
	Latitude       decimal.Decimal `db:"Latitude" json:"latitude"`
	OnlineStatus   bool            `db:"OnlineStatus" json:"onlineStatus"`
	MiningPower    *float64        `db:"MiningPower" json:"miningPower"`
	IsMinable      bool            `db:"IsMinable" json:"isMinable"`
	DID            string          `db:"DID" json:"did"`
	Host           string          `db:"Host" json:"host"`
	IsVirtual      bool            `db:"IsVirtual" json:"isVirtual"`
	DeviceName     string          `db:"DeviceName" json:"deviceName"`
	Location       string          `db:"Location" json:"location"`
	RewardEarned   string          `db:"RewardEarned" json:"rewardEarned"`
	SignalStrength string          `db:"SignalStrength" json:"signalStrength"`
	CreateTime     *time.Time      `db:"CreateTime" json:"createTime"`
}

type VCSchemaChanged struct {
	VcName string
	Name   [32]byte
	Value  []byte
}

type WifiUserInfo struct {
	Username string `json:"username" db:"username"`
	Password string `json:"password" db:"value"`
}

func CreateDIDDocument() *DIDDocument {
	return &DIDDocument{}
}

func NewRegisterDID() *RegisterDID {
	return &RegisterDID{}
}

func (doc DIDDocument) RetrieveVerificationMethod(vmID string) (VerificationMethod, error) {
	for _, vm := range doc.VerificationMethod {
		if vm.ID == vmID {
			return vm, nil
		}
	}
	return VerificationMethod{}, errval.ErrMissingVM
}

func (doc *DIDDocument) AddService(service Service) {
	doc.Service = append(doc.Service, service)
}

func CreateVerifiableCredential() *VerifiableCredential {
	return &VerifiableCredential{}
}

func NewVerifiableCredential(context []string, id string, vctype []string, issuer, issuanceDate, expirationDate, description string, subject interface{}, proof VCProof, revoked bool) *VerifiableCredential {
	return &VerifiableCredential{
		Context:           context,
		ID:                id,
		Type:              vctype,
		Issuer:            issuer,
		IssuanceDate:      issuanceDate,
		ExpirationDate:    expirationDate,
		Description:       description,
		CredentialSubject: subject,
		Proof:             proof,
		Revoked:           revoked,
	}
}

func CreateSubjectInfo() *SubjectInfo {
	return &SubjectInfo{}
}

func CreateWifiAccessInfo() *WifiAccessInfo {
	return &WifiAccessInfo{}
}

func CreateMiningLicenseInfo() *MiningLicenseInfo {
	return &MiningLicenseInfo{}
}

func CreateVCProof() *VCProof {
	return &VCProof{}
}

func CreateVPProof() *VPProof {
	return &VPProof{}
}

func CreateResolutionOptions() *ResolutionOptions {
	return &ResolutionOptions{}
}

func CreatePresentation() *VerifiablePresentation {
	return &VerifiablePresentation{}
}

func CreateMinerInfo() *MinerInfo {
	return &MinerInfo{}
}

func NewPresentation(context, presentationType []string, credentials []VerifiableCredential, holder string, proof VPProof) *VerifiablePresentation {
	return &VerifiablePresentation{
		Context:              context,
		Type:                 presentationType,
		VerifiableCredential: credentials,
		Holder:               holder,
		Proof:                proof,
	}
}

func GenerateTestPrivKey() *ecdsa.PrivateKey {
	privKey, _ := crypto.ToECDSA(common.Hex2Bytes("dbbd9634560466ac9713e0cf10a575456c8b55388bce0c044f33fc6074dc5ae6"))
	return privKey
}

func GenerateTestDIDDocument() *DIDDocument {
	document := CreateDIDDocument()
	document.Context = append(document.Context, ContextSecp256k1)
	document.Context = append(document.Context, ContextDID)
	document.ID = "did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX"
	document.Created = "2022-03-31T12:53:19-07:00"
	document.Updated = "2022-03-31T12:53:19-07:00"
	document.Version = 1
	document.VerificationMethod = append(document.VerificationMethod, VerificationMethod{ID: "did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification", MethodType: "EcdsaSecp256k1RecoveryMethod2020", Controller: "did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX", BlockchainAccountId: "eip155:1666600000:0xBE1e1dB948CC1f441514aFb8924B67891f1c6889"})
	document.Authentication = "did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification"
	return document
}

func GenerateTestResolvedDIDDocument() *DIDDocument {
	document := GenerateTestDIDDocument()
	document.VerificationMethod[0].BlockchainAccountId = "eip155:1666600000:0x25007b7AB5b0717F2Edd155F70746719e1862A52"
	return document
}

func NewSubjectInfo(id string, givenName, familyName, gender, birthCountry, birthDate string) *SubjectInfo {
	return &SubjectInfo{
		ID:           id,
		GivenName:    givenName,
		FamilyName:   familyName,
		Gender:       gender,
		BirthCountry: birthCountry,
		BirthDate:    birthDate,
	}
}

func GenerateTestSubjectInfo() *SubjectInfo {
	return NewSubjectInfo(
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX",
		"John",
		"Jacobs",
		"Male",
		"Canada",
		"2022-03-22",
	)
}

func NewWifiAccessInfo(credentialID, id, userType string) *WifiAccessInfo {
	return &WifiAccessInfo{
		CredentialID: credentialID,
		ID:           id,
		Type:         userType,
	}
}

func GenerateTestWifiAccessInfo() *WifiAccessInfo {
	return NewWifiAccessInfo(
		"sampleID",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX",
		"User",
	)
}

func NewMiningLicenseInfo(credentialID, id, name, model, serial string) *MiningLicenseInfo {
	return &MiningLicenseInfo{
		CredentialID: credentialID,
		ID:           id,
		Name:         name,
		Model:        model,
		Serial:       serial,
	}
}

func GenerateTestMiningLicenseInfo() *MiningLicenseInfo {
	return NewMiningLicenseInfo(
		"1",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX",
		"TestName",
		"TestModel",
		"TestSerial",
	)
}

func NewVCProof(proofType, created, vm, purpose, sig string, pubKey []byte) *VCProof {
	return &VCProof{
		Type:               proofType,
		Created:            created,
		VerificationMethod: vm,
		ProofPurpose:       purpose,
		JWSSignature:       sig,
		PublicKeyString:    pubKey,
	}
}

func NewVPProof(proofType, created, vm, purpose, sig, nonce string, pubKey []byte) *VPProof {
	return &VPProof{
		Type:               proofType,
		Created:            created,
		VerificationMethod: vm,
		ProofPurpose:       purpose,
		JWSSignature:       sig,
		Nonce:              nonce,
		PublicKeyString:    pubKey,
	}
}

func GenerateTestVC() *VerifiableCredential {
	vcProof := NewVCProof(
		Secp256k1Sig,
		"2022-03-31T12:53:19-07:00",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification",
		PurposeAuth,
		"eyJhbGciOiJFUzI1NiJ9..IklF2w-lM8CDeBBxKjoAEf_t22jngbmtI9n7hd_47zE_d2Qcj2kwHBHwHFVOTL3nqTrkycVdZmWtgw3M6tMqoA",
		[]byte{4, 103, 89, 134, 238, 118, 86, 61, 43, 58, 216, 220, 171, 26, 136, 74, 220, 205, 222, 156, 30, 162, 206, 49, 234, 95, 43, 142, 116, 148, 41, 186, 156, 198, 8, 168, 219, 47, 3, 102, 97, 180, 96, 99, 19, 32, 179, 209, 93, 56, 16, 195, 2, 144, 196, 166, 145, 6, 168, 114, 247, 0, 246, 116, 118},
	)

	subjectInfo := GenerateTestSubjectInfo()

	return NewVerifiableCredential(
		[]string{ContextCredential, ContextSecp256k1},
		"http://metablox.com/credentials/1",
		[]string{TypeCredential, "PermanentResidentCard"},
		"did:metablox:sampleIssuer",
		"2022-03-31T12:53:19-07:00",
		"2032-03-31T12:53:19-07:00",
		"Government of Example Permanent Resident Card",
		*subjectInfo,
		*vcProof,
		false,
	)
}

func GenerateTestWifiAccessVC() *VerifiableCredential {
	vcProof := NewVCProof(
		Secp256k1Sig,
		"2022-03-31T12:53:19-07:00",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification",
		PurposeAuth,
		"eyJhbGciOiJFUzI1NiJ9..SnGaW3ya8MM-DXbRSFXWHM_R7Vg_3u_u1OxEfxvwXzQWNRmmC5noWvleSEM3iQdofm7towbpJ6nABQs9e1-OvA",
		[]byte{4, 103, 89, 134, 238, 118, 86, 61, 43, 58, 216, 220, 171, 26, 136, 74, 220, 205, 222, 156, 30, 162, 206, 49, 234, 95, 43, 142, 116, 148, 41, 186, 156, 198, 8, 168, 219, 47, 3, 102, 97, 180, 96, 99, 19, 32, 179, 209, 93, 56, 16, 195, 2, 144, 196, 166, 145, 6, 168, 114, 247, 0, 246, 116, 118},
	)

	wifiAccessInfo := GenerateTestWifiAccessInfo()

	return NewVerifiableCredential(
		[]string{ContextSecp256k1, ContextCredential},
		"http://metablox.com/credentials/1",
		[]string{TypeCredential, TypeWifi},
		"did:metablox:sampleIssuer",
		"2022-03-31T12:53:19-07:00",
		"2032-03-31T12:53:19-07:00",
		"Example Wifi Access Credential",
		*wifiAccessInfo,
		*vcProof,
		false,
	)
}

func GenerateTestMiningLicenseVC() *VerifiableCredential {
	vcProof := NewVCProof(
		Secp256k1Sig,
		"2022-03-31T12:53:19-07:00",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification",
		PurposeAuth,
		"eyJhbGciOiJFUzI1NiJ9..SnGaW3ya8MM-DXbRSFXWHM_R7Vg_3u_u1OxEfxvwXzQWNRmmC5noWvleSEM3iQdofm7towbpJ6nABQs9e1-OvA",
		[]byte{4, 103, 89, 134, 238, 118, 86, 61, 43, 58, 216, 220, 171, 26, 136, 74, 220, 205, 222, 156, 30, 162, 206, 49, 234, 95, 43, 142, 116, 148, 41, 186, 156, 198, 8, 168, 219, 47, 3, 102, 97, 180, 96, 99, 19, 32, 179, 209, 93, 56, 16, 195, 2, 144, 196, 166, 145, 6, 168, 114, 247, 0, 246, 116, 118},
	)

	miningLicenseInfo := GenerateTestMiningLicenseInfo()

	return NewVerifiableCredential(
		[]string{ContextSecp256k1, ContextCredential},
		"http://metablox.com/credentials/1",
		[]string{TypeCredential, TypeMining},
		"did:metablox:sampleIssuer",
		"2022-03-31T12:53:19-07:00",
		"2032-03-31T12:53:19-07:00",
		"Example Mining License Credential",
		*miningLicenseInfo,
		*vcProof,
		false,
	)
}

func CreateService() *Service {
	return &Service{}
}

func GenerateTestPresentation() *VerifiablePresentation {
	vpProof := NewVPProof(
		Secp256k1Sig,
		"2022-03-31T12:53:19-07:00",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification",
		PurposeAuth,
		"eyJhbGciOiJFUzI1NiJ9..PKCD7kcMsRLD2hYGvkdvsYxpIT-krrkYs4VZmjqYOZ4gtUEYkKpZKW8cUUSHmF0Tb4IxkGaq3b4H__3HiQNGyw",
		"sampleNonce",
		[]byte{4, 103, 89, 134, 238, 118, 86, 61, 43, 58, 216, 220, 171, 26, 136, 74, 220, 205, 222, 156, 30, 162, 206, 49, 234, 95, 43, 142, 116, 148, 41, 186, 156, 198, 8, 168, 219, 47, 3, 102, 97, 180, 96, 99, 19, 32, 179, 209, 93, 56, 16, 195, 2, 144, 196, 166, 145, 6, 168, 114, 247, 0, 246, 116, 118},
	)

	return NewPresentation(
		[]string{ContextSecp256k1, ContextCredential},
		[]string{"VerifiablePresentation"},
		[]VerifiableCredential{*GenerateTestVC()},
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX",
		*vpProof,
	)
}

func GenerateTestWifiAccessPresentation() *VerifiablePresentation {
	vpProof := NewVPProof(
		Secp256k1Sig,
		"2022-03-31T12:53:19-07:00",
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX#verification",
		PurposeAuth,
		"eyJhbGciOiJFUzI1NiJ9..bmj6KhHcBkLOHgAZrLqgweE-StyBXvvj6bmZqC6TqiYVtC_tXf076xDAAXzmx160dAqivTzgX-943ZU-VWXDqw",
		"123456",
		[]byte{4, 103, 89, 134, 238, 118, 86, 61, 43, 58, 216, 220, 171, 26, 136, 74, 220, 205, 222, 156, 30, 162, 206, 49, 234, 95, 43, 142, 116, 148, 41, 186, 156, 198, 8, 168, 219, 47, 3, 102, 97, 180, 96, 99, 19, 32, 179, 209, 93, 56, 16, 195, 2, 144, 196, 166, 145, 6, 168, 114, 247, 0, 246, 116, 118},
	)

	return NewPresentation(
		[]string{ContextCredential, ContextSecp256k1},
		[]string{"VerifiablePresentation"},
		[]VerifiableCredential{*GenerateTestWifiAccessVC()},
		"did:metablox:7rb6LjVKYSEf4LLRqbMQGgdeE8MYXkfS7dhjvJzUckEX",
		*vpProof,
	)
}
